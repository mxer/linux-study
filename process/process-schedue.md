## 进程调度
进程调度是现代操作系统要解决的问题，调度的对象是处于TASK_RUNNING状态的进程
linux是多任务的操作系统，所谓多任务就是指系统能够同时并发地执行多个进程，在单处理器上给人多个进程同时跑的感觉，事实上多个进程是轮流使用CPU资源，只有在多核处理器上，多个进程才能做到同时跑，并行地执行

### 系统分类
```
按多任务系统分类:
1. 非抢占式多任务:下一个任务被调度的前提是当前进程主动让出CPU的使用权，又称为合作型多任务
2. 抢占式多任务:由操作系统来决定进程调度，linux属于抢占式多任务系统

按行为模式分类:
1. CPU消耗型:始终处于可执行状态，始终在执行指令
2. I/O消耗型:有大量I/O，处于可执行状态的时间不多
```

### 进程调度器需要达成的目标
```
1. 公平
2. 高吞吐量
3. 简单高效
4. 低耗电量
5. 负载均衡
6. 差异化
```

### 多CPU系统
```
目前linux采用的是每个CPU都有自己的运行队列，即per cpu run queue。每个CPU都去自己的运行队列中选择进程，这样降低了多个CPU之间的竞争

load_balance的任务就是解决多CPU之间负载不均的问题，将任务从一个CPU运行队列移动到另一个CPU运行队列
```

### 进程调度的职责
```
挑选下一个执行的进程，如果下一个被调度的进程和调度前运行的进程不是同一个，则执行上线文切换，将新选择的进程投入运行
```

### 4种调度类
```
stop_sched_class 停止类
rt_sched_class 实时类
fair_sched_class 完全公平调度类
idle_sched_class 空闲类

这4种调度类是按照优先级顺序排列的，挑选下一个执行进程的优先级顺序:
停止类 > 实时类 > 完全公平调度类 > 空闲类 

```


