## 进程调度
进程调度是现代操作系统要解决的问题，调度的对象是处于TASK_RUNNING状态的进程
linux是多任务的操作系统，所谓多任务就是指系统能够同时并发地执行多个进程，在单处理器上给人多个进程同时跑的感觉，事实上多个进程是轮流使用CPU资源，只有在多核处理器上，多个进程才能做到同时跑，并行地执行

### 系统分类
```
按多任务系统分类:
1. 非抢占式多任务:下一个任务被调度的前提是当前进程主动让出CPU的使用权，又称为合作型多任务
2. 抢占式多任务:由操作系统来决定进程调度，linux属于抢占式多任务系统

按行为模式分类:
1. CPU消耗型:始终处于可执行状态，始终在执行指令
2. I/O消耗型:有大量I/O，处于可执行状态的时间不多
```

### 进程调度器需要达成的目标
```
1. 公平
2. 高吞吐量
3. 简单高效
4. 低耗电量
5. 负载均衡
6. 差异化
```

### 多CPU系统
```
目前linux采用的是每个CPU都有自己的运行队列，即per cpu run queue。每个CPU都去自己的运行队列中选择进程，这样降低了多个CPU之间的竞争

load_balance的任务就是解决多CPU之间负载不均的问题，将任务从一个CPU运行队列移动到另一个CPU运行队列
```

### 进程调度的职责
```
挑选下一个执行的进程，如果下一个被调度的进程和调度前运行的进程不是同一个，则执行上线文切换，将新选择的进程投入运行
```

### 4种调度类
```
stop_sched_class 停止类
rt_sched_class 实时类
fair_sched_class 完全公平调度类
idle_sched_class 空闲类

这4种调度类是按照优先级顺序排列的，挑选下一个执行进程的优先级顺序:
停止类 > 实时类 > 完全公平调度类 > 空闲类 

每个CPU都对应一个停止类和一个空闲类，和应用层无关的，应用层无法设置停止类进程或空闲类进程

和应用层关系密切的是 实时类 和 完全公平调度类
```

### 完全公平调度类 CFS (Completely Fair Scheduler)
完全公平调度使用了一种动态时间片的算法。它给每个进程分配了使用CPU的时间比例。
```
调度延迟: 即保证每一个可运行的进程至少运行一次的时间间隔(单位:纳秒)
# cat /proc/sys/kernel/sched_latency_ns
6000000

调度最小粒度: 是指任一进程所运行的时间长度的基准值，任何一个进程只要分配到CPU资源，都至少会执行调度最小粒度的时间，除非在执行过程中执行了阻塞或者主动让出CPU资源(通过sched_yield调用)(单位:纳秒)
# cat /proc/sys/kernel/sched_min_granularity_ns
10000000

调度周期 sched_nr_latency =  sched_latency_ns / sched_min_granularity_ns
1.若运行队列中进程个数小于或等于sched_nr_latency，那么调度周期等于调度延迟
2.若运行队列中进程个数大于sched_nr_latency，那么调度周期则等于可运行进程个数与调度最小粒度的乘积

分配给进程的运行时间 = 调度周期*1/运行队列上进程个数
```

### 优先级
```
上面的情况是基于运行队列上所有进程都是相同优先级的假设，真实的情况并非如此，完全公平调度又引入了优先级的概念

完全公平调度通过引入权重来实现优先级，进程质检安装权重的比例分配CPU时间片

分配给进程的运行时间 = 调度周期*进程权重/运行队列上所有进程权重之和

linux下每个进程都有一个nice值，该值的范围是[-20, 19]，nice值越高，表示优先级越低，默认是0

权重计算:
weight = 1024/(1.25 ^ nice_value)

1.25怎么来的?
进程每降低一个nice值，将多获得10%的CPU时间
```

### 修改nice值
```
#include<sys/time.h>
#include<sys/resource.h>
int getpriority(int which, int who);
int setpriority(int which, int who, int prio);
int which 取值 PRIO_PROCESS、PRIO_PGRP、PRIO_USER
1. which == PRIO_PROCESS
    int who 进程id，如果id=0，表示设置调用的进程id
2. which == PRIO_PGRP
    int who 进程组id，如果id=0，表示设置调用的进程组id
3. which == PRIO_USER
    int who 真实用户id，如果id=0，表示设置调用者真实用户id

getpriority函数返回which和who指定进程的nice值，如果存在多个进程符合指定的标注，则返回优先级最高的那个进程的nice值，即nice值最小的那个

getpriority函数返回值可能为-1，所以不能用-1来判断调用成功或失败，可以先设置errno=0，判断errno!=0就是失败
```

### 完全公平调度的实现
```
虚拟运行时间:对于优先级不同的进程，转换成在CPU上执行相同比例的时间
比如:2个进程，权重是3:1，运行时间是15ms和5ms，就可以认为
    第一个进程15ms的记账值==第二个进程5ms的记账值
这样2个进程就能根据时间记账值的大小交替运行了

这种时间加权记账的思想就是完全公平调度的核心

虚拟运行时间(加权运行时间) = 真实运行时间*(NICE_0_LOAD/进程权重)

内核使用红黑树来存储运行队列进程，当调度的时候只需从红黑树中取出虚拟运行时间最小的进行调度即可
因此维护进程的虚拟运行时间就从了调度算法的关键，内核会周期性地更新进程的虚拟运行时间
```

### 周期性调度任务
```
周期性调度任务是调度框架中很重要的一个部分，因此Linux是抢占式多任务，系统需要周期性地检查当前进程是不是已经耗尽它的时间片，是不是应该发起一次抢占。这就是周期性调度任务的职责
```

### 父子进程谁先执行
```
# cat /proc/sys/kernel/sched_child_runs_first
0
该选项配置是1的话，fork之后子进程将优先获得调度，是0的话，父进程优先获得调度，内核2.6.32开始，默认是0
```

### 睡眠进程
```
如何对待睡眠进程也是调度器需要解决的问题
1. 把从休眠中醒来的进程放到合适的运行队列
2. 将进程的状态设置为TASK_RUNNING
3. 判断醒来的进程是否应该抢占当前正在运行的进程，如果是，则设置need_resched标志位
```

### 普通进程的组调度
```
完全公平调度算法会尽力在进程之间保证公平，如果有50个进程，每个进程2%的CPU时间
其中A用户有49个人进程，B用户有1个进程，对于B用户只有2%的CPU时间显然是不公平的
比较合理的做法是，首先确保组间的公平，然后才是组内进程之间的公平

调度器会把整个组看成是一个进程来对待
```